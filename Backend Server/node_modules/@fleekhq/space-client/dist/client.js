"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const empty_pb_1 = require("google-protobuf/google/protobuf/empty_pb");
const SpaceServiceClientPb_1 = require("./definitions/SpaceServiceClientPb");
const space_pb_1 = require("./definitions/space_pb");
const DEFAULT_BUCKET = 'personal';
class SpaceClient {
    constructor(opts) {
        const { url, options, credentials, defaultBucket = DEFAULT_BUCKET, } = opts;
        this.defaultBucket = defaultBucket;
        this.instance = new SpaceServiceClientPb_1.SpaceApiClient(url, credentials, options);
    }
    listDirectory(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ListDirectoryRequest();
            const path = payload.path.replace(/^\//, '');
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setPath(path);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.listDirectory(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    listDirectories(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ListDirectoriesRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setBucket(bucket || this.defaultBucket);
            this.instance.listDirectories(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    txlSubscribe(metadata = {}) {
        const request = new empty_pb_1.Empty();
        return this.instance.txlSubscribe(request, metadata);
    }
    openFile(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.OpenFileRequest();
            const path = payload.path.replace(/^\//, '');
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setPath(path);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.openFile(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    createBucket(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.CreateBucketRequest();
            request.setSlug(payload.slug);
            this.instance.createBucket(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    addItems(payload, metadata = {}) {
        const request = new space_pb_1.AddItemsRequest();
        const targetPath = payload.targetPath.replace(/^\//, '');
        const bucket = payload.bucket === '' ? null : payload.bucket;
        request.setTargetpath(targetPath);
        request.setSourcepathsList(payload.sourcePaths);
        request.setBucket(bucket || this.defaultBucket);
        const stream = this.instance.addItems(request, metadata);
        return stream;
    }
    createFolder(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.CreateFolderRequest();
            const path = payload.path.replace(/^\//, '');
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setPath(path);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.createFolder(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    createUsernameAndEmail(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.CreateUsernameAndEmailRequest();
            request.setEmail(payload.email || '');
            request.setUsername(payload.username);
            this.instance.createUsernameAndEmail(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    getIdentityByUsername(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GetIdentityByUsernameRequest();
            request.setUsername(payload.username);
            this.instance.getIdentityByUsername(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    /**
     * [WIP] shareBucketViaEmail
     *
     * Not supported by space daemon
     */
    shareBucketViaEmail(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ShareBucketViaEmailRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setEmail(payload.email);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.shareBucketViaEmail(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    shareBucketViaIdentity(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ShareBucketViaIdentityRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setIdentitytype(space_pb_1.IdentityType[payload.identityType]);
            request.setIdentityvalue(payload.identityValue);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.shareBucketViaIdentity(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    /**
     * [WIP] generateFileShareLink
     *
     * Not supported by space daemon
     */
    generateFileShareLink(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.GenerateFileShareLinkRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setFilepath(payload.filePath);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.generateFileShareLink(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    /**
     * [WIP] backupKeysByPassphrase
     *
     * Not supported by space daemon
     */
    backupKeysByPassphrase(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.BackupKeysByPassphraseRequest();
            request.setPassphrase(payload.passphrase);
            this.instance.backupKeysByPassphrase(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    /**
     * [WIP] recoverKeysByPassphrase
     *
     * Not supported by space daemon
     */
    recoverKeysByPassphrase(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.RecoverKeysByPassphraseRequest();
            request.setPassphrase(payload.passphrase);
            this.instance.recoverKeysByPassphrase(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    /**
     * [WIP] toggleFuseDrive
     *
     * Not supported by space daemon
     */
    toggleFuseDrive(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ToggleFuseRequest();
            request.setMountdrive(payload.mountDrive);
            this.instance.toggleFuseDrive(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    /**
     * [WIP] getFuseDriveStatus
     *
     * Not supported by space daemon
     */
    getFuseDriveStatus(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new empty_pb_1.Empty();
            this.instance.getFuseDriveStatus(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    subscribe(metadata = {}) {
        const request = new empty_pb_1.Empty();
        return this.instance.subscribe(request, metadata);
    }
    /**
     * [WIP] listBuckets
     *
     * Not supported by space daemon
     */
    listBuckets(metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ListBucketsRequest();
            this.instance.listBuckets(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    shareBucket(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const request = new space_pb_1.ShareBucketRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setBucket(bucket || this.defaultBucket);
            this.instance.shareBucket(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
    joinBucket(payload, metadata = {}) {
        return new Promise((resolve, reject) => {
            const threadInfo = new space_pb_1.ThreadInfo();
            threadInfo.setKey(payload.threadInfo.key);
            threadInfo.setAddressesList(payload.threadInfo.addresses);
            const request = new space_pb_1.JoinBucketRequest();
            const bucket = payload.bucket === '' ? null : payload.bucket;
            request.setThreadinfo(threadInfo);
            request.setBucket(bucket || this.defaultBucket);
            this.instance.joinBucket(request, metadata, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res);
            });
        });
    }
}
exports.default = SpaceClient;
//# sourceMappingURL=client.js.map